<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Healthimpro — Camera + Grid</title>
  <style>
    body { margin:0; background:#000; overflow:hidden; font-family: Arial, sans-serif; }
    #stage { position:relative; width:100vw; height:100vh; background:#000; }
    video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
    #overlay { pointer-events:none; }

    #hud {
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      background: rgba(0,0,0,0.65); color:#fff;
      padding:10px 12px; border-radius:12px; z-index:10;
    }
    #hud input, #hud button {
      font-size:16px; padding:10px 12px; border-radius:10px; border:0; outline:none;
    }
    #hud input { width:130px; }

    #countdown {
      position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
      background: rgba(0,0,0,0.55); color:#fff;
      width:140px; height:140px; border-radius:70px;
      display:none; align-items:center; justify-content:center;
      font-size:64px; font-weight:700; z-index:11;
      border: 3px solid rgba(255,255,255,0.25);
    }

    #captures {
      position:fixed; right:10px; top:10px; z-index:20;
      max-height: calc(100vh - 20px); overflow:auto; width:min(240px, 55vw);
      display:flex; flex-direction:column; gap:10px;
    }
    #captures img { width:100%; display:block; border-radius:10px; border:1px solid rgba(255,255,255,0.15); }
  </style>
</head>
<body>
  <div id="stage">
    <video id="video" playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="countdown">8</div>
  <div id="captures"></div>

  <div id="hud">
    <input id="heightCm" type="number" min="80" max="250" placeholder="Рост (см)" />
    <button id="btnStart">Включить камеру</button>
    <button id="btnSwitch">Сменить камеру</button>
    <button id="btnPhoto">Сделать фото</button>
  </div>

<script>
(() => {
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const octx = overlay.getContext('2d');
  const heightInput = document.getElementById('heightCm');

  const btnStart = document.getElementById('btnStart');
  const btnSwitch = document.getElementById('btnSwitch');
  const btnPhoto = document.getElementById('btnPhoto');

  const countdownEl = document.getElementById('countdown');
  const captures = document.getElementById('captures');

  let stream = null;
  let facing = 'user'; // front by default

  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

  async function waitForVideoReady(timeoutMs = 3500) {
    const t0 = performance.now();
    while (performance.now() - t0 < timeoutMs) {
      if (video.videoWidth > 0 && video.videoHeight > 0) return true;
      await sleep(16);
    }
    return false;
  }

  function syncOverlaySize() {
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;
    if (vw && vh && (overlay.width !== vw || overlay.height !== vh)) {
      overlay.width = vw;
      overlay.height = vh;
    }
  }

  async function startCamera() {
    if (stream) stream.getTracks().forEach(t => t.stop());
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: facing }, audio: false
    });
    video.srcObject = stream;
    video.muted = true;
    await video.play();

    const ok = await waitForVideoReady();
    if (ok) syncOverlaySize();
  }

  function drawOverlay() {
    if (!overlay.width || !overlay.height) return;

    const h = parseInt(heightInput.value, 10);
    const W = overlay.width;
    const H = overlay.height;

    octx.clearRect(0, 0, W, H);

    // GRID (neutral) — scaled by height
    if (h && h > 0) {
      const pxPerCm = H / h;
      const stepCm = 10;
      const stepPx = stepCm * pxPerCm;

      octx.lineWidth = 1;
      octx.strokeStyle = 'rgba(255,255,255,0.18)';

      for (let x = 0; x <= W; x += stepPx) {
        octx.beginPath(); octx.moveTo(x, 0); octx.lineTo(x, H); octx.stroke();
      }
      for (let y = 0; y <= H; y += stepPx) {
        octx.beginPath(); octx.moveTo(0, y); octx.lineTo(W, y); octx.stroke();
      }
    }

    // central axis (blue)
    octx.lineWidth = 2;
    octx.strokeStyle = 'rgba(0,170,255,0.85)';
    octx.beginPath();
    octx.moveTo(W/2, 0);
    octx.lineTo(W/2, H);
    octx.stroke();

    // levels (red) — separate from grid (MVP fixed ratios)
    const yShoulders = H * 0.28;
    const yPelvis   = H * 0.58;

    octx.lineWidth = 3;
    octx.strokeStyle = 'rgba(255,0,0,0.85)';
    octx.beginPath(); octx.moveTo(0, yShoulders); octx.lineTo(W, yShoulders); octx.stroke();
    octx.beginPath(); octx.moveTo(0, yPelvis);   octx.lineTo(W, yPelvis);   octx.stroke();

    // neck tilt hint line (red)
    octx.strokeStyle = 'rgba(255,0,0,0.75)';
    const cx = W/2;
    const ny = H * 0.18;
    octx.beginPath();
    octx.moveTo(cx - W*0.06, ny + H*0.02);
    octx.lineTo(cx + W*0.06, ny - H*0.03);
    octx.stroke();
  }

  function rafLoop() {
    // keep sizes in sync (important for capture!)
    if (video.videoWidth && video.videoHeight) syncOverlaySize();
    drawOverlay();
    requestAnimationFrame(rafLoop);
  }

  function runCountdown(seconds) {
    return new Promise(resolve => {
      let s = seconds;
      countdownEl.textContent = String(s);
      countdownEl.style.display = 'flex';

      const t = setInterval(() => {
        s -= 1;
        if (s <= 0) {
          clearInterval(t);
          countdownEl.style.display = 'none';
          resolve();
        } else {
          countdownEl.textContent = String(s);
        }
      }, 1000);
    });
  }

  function captureWithOverlay() {
    const W = overlay.width || video.videoWidth;
    const H = overlay.height || video.videoHeight;
    if (!W || !H) return null;

    const out = document.createElement('canvas');
    out.width = W; out.height = H;
    const ctx = out.getContext('2d');

    ctx.drawImage(video, 0, 0, W, H);
    ctx.drawImage(overlay, 0, 0, W, H);

    return out.toDataURL('image/png');
  }

  async function takePhoto() {
    if (!video.srcObject) return alert('Сначала включи камеру');

    const ok = await waitForVideoReady();
    if (!ok) return alert('Видео ещё не готово');

    syncOverlaySize(); // critical: ensure overlay has real size
    drawOverlay();     // critical: ensure overlay has current frame

    if (facing === 'user') {
      await runCountdown(8); // <- 8 sec timer back
      // after countdown, refresh overlay once more
      syncOverlaySize();
      drawOverlay();
    }

    const dataUrl = captureWithOverlay();
    if (!dataUrl) return alert('Не удалось сделать фото');

    const img = document.createElement('img');
    img.src = dataUrl;
    captures.prepend(img);
  }

  btnStart.addEventListener('click', startCamera);
  btnSwitch.addEventListener('click', async () => {
    facing = (facing === 'user') ? 'environment' : 'user';
    await startCamera();
  });
  btnPhoto.addEventListener('click', takePhoto);

  rafLoop();
})();
</script>
</body>
</html>
